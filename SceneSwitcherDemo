import cv2
import time
import threading
import logging
from obswebsocket import obsws, requests
from collections import deque

# ==============================

# LOGGING SETUP

# ==============================

logging.basicConfig(
level=logging.INFO,
format=’[%(asctime)s] [%(levelname)s] %(message)s’,
datefmt=’%H:%M:%S’
)
logger = logging.getLogger(**name**)

# ==============================

# CONFIGURATION

# ==============================

OBS_HOST = “localhost”
OBS_PORT = 4455
OBS_PASSWORD = “your_password_here”

SCENE_BLOCKS = “Blocks”  # Scene for start/end camera
SCENE_TURNS = “Turns”    # Scene for turns camera

CAMERA_BLOCKS = 0  # Camera index for blocks area
CAMERA_TURNS = 1   # Camera index for turns area

MOTION_SENSITIVITY = 5000     # Minimum motion area to count as active
DEBOUNCE_DELAY = 1.5          # Seconds before confirming a scene switch
CHECK_INTERVAL = 0.1          # How often to check for motion (sec)
MOTION_HISTORY_SIZE = 5       # Number of frames to average for stability

# Camera settings

CAMERA_WIDTH = 640
CAMERA_HEIGHT = 480
CAMERA_FPS = 30

# Placeholder race state

race_running = False

# ==============================

# OBS CONNECTION

# ==============================

class OBSController:
def **init**(self, host, port, password):
self.host = host
self.port = port
self.password = password
self.ws = None
self.connected = False
self.lock = threading.Lock()

```
def connect(self):
    """Establish connection to OBS."""
    try:
        self.ws = obsws(self.host, self.port, self.password)
        self.ws.connect()
        self.connected = True
        logger.info("OBS connected successfully")
        return True
    except Exception as e:
        logger.error(f"OBS connection failed: {e}")
        self.connected = False
        return False

def disconnect(self):
    """Safely disconnect from OBS."""
    with self.lock:
        if self.ws and self.connected:
            try:
                self.ws.disconnect()
                logger.info("OBS disconnected")
            except Exception as e:
                logger.error(f"Error disconnecting from OBS: {e}")
            finally:
                self.connected = False

def switch_scene(self, scene_name):
    """Switch to a given scene in OBS."""
    if not self.connected:
        logger.warning("Cannot switch scene - OBS not connected")
        return False
        
    with self.lock:
        try:
            self.ws.call(requests.SetCurrentProgramScene(sceneName=scene_name))
            logger.info(f"Switched to scene: {scene_name}")
            return True
        except Exception as e:
            logger.error(f"Scene switch failed: {e}")
            return False

def get_current_scene(self):
    """Get the current active scene."""
    if not self.connected:
        return None
        
    with self.lock:
        try:
            response = self.ws.call(requests.GetCurrentProgramScene())
            return response.datain.get('currentProgramSceneName')
        except Exception as e:
            logger.error(f"Failed to get current scene: {e}")
            return None
```

# ==============================

# CAMERA MANAGER

# ==============================

class CameraManager:
def **init**(self, camera_index, name, width=CAMERA_WIDTH, height=CAMERA_HEIGHT):
self.camera_index = camera_index
self.name = name
self.cap = None
self.subtractor = None
self.motion_history = deque(maxlen=MOTION_HISTORY_SIZE)
self.is_initialized = False
self.lock = threading.Lock()
self.width = width
self.height = height

```
def initialize(self):
    """Initialize camera and background subtractor."""
    try:
        self.cap = cv2.VideoCapture(self.camera_index)
        if not self.cap.isOpened():
            logger.error(f"Failed to open camera {self.name} (index {self.camera_index})")
            return False
        
        # Set camera properties
        self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, self.width)
        self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, self.height)
        self.cap.set(cv2.CAP_PROP_FPS, CAMERA_FPS)
        
        # Warm up camera
        for _ in range(5):
            self.cap.read()
        
        self.subtractor = cv2.createBackgroundSubtractorMOG2(
            history=300, 
            varThreshold=50, 
            detectShadows=True
        )
        
        self.is_initialized = True
        logger.info(f"Camera {self.name} initialized successfully")
        return True
        
    except Exception as e:
        logger.error(f"Failed to initialize camera {self.name}: {e}")
        return False

def get_motion_level(self):
    """Return averaged motion level from recent frames."""
    if not self.is_initialized:
        return 0
    
    with self.lock:
        try:
            ret, frame = self.cap.read()
            if not ret or frame is None:
                logger.warning(f"Failed to read frame from {self.name}")
                return 0
            
            # Convert to grayscale
            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            
            # Apply Gaussian blur to reduce noise
            gray = cv2.GaussianBlur(gray, (21, 21), 0)
            
            # Get foreground mask
            fgmask = self.subtractor.apply(gray)
            
            # Threshold and find contours
            _, thresh = cv2.threshold(fgmask, 200, 255, cv2.THRESH_BINARY)
            
            # Morphological operations to remove noise
            kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
            thresh = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel)
            thresh = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel)
            
            contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
            total_area = sum(cv2.contourArea(c) for c in contours)
            
            # Add to history and return average
            self.motion_history.append(total_area)
            avg_motion = sum(self.motion_history) / len(self.motion_history)
            
            return avg_motion
            
        except Exception as e:
            logger.error(f"Error getting motion level from {self.name}: {e}")
            return 0

def release(self):
    """Release camera resources."""
    with self.lock:
        if self.cap:
            self.cap.release()
            logger.info(f"Camera {self.name} released")
```

# ==============================

# AUTO SWITCHER

# ==============================

class AutoCameraSwitcher:
def **init**(self, obs_controller, cam_blocks, cam_turns):
self.obs = obs_controller
self.cam_blocks = cam_blocks
self.cam_turns = cam_turns
self.current_scene = SCENE_BLOCKS
self.last_switch_time = time.time()
self.running = False
self.thread = None

```
def start(self):
    """Start the auto-switching thread."""
    if self.running:
        logger.warning("Auto-switcher already running")
        return
    
    self.running = True
    self.thread = threading.Thread(target=self._motion_loop, daemon=True)
    self.thread.start()
    logger.info("Auto-switcher started")

def stop(self):
    """Stop the auto-switching thread."""
    self.running = False
    if self.thread:
        self.thread.join(timeout=2)
    logger.info("Auto-switcher stopped")

def _motion_loop(self):
    """Main motion detection loop."""
    while self.running:
        if not race_running:
            time.sleep(0.5)
            continue
        
        # Get motion levels from both cameras
        motion_blocks = self.cam_blocks.get_motion_level()
        motion_turns = self.cam_turns.get_motion_level()
        
        # Debug output (uncomment if needed)
        # logger.debug(f"Motion - Blocks: {motion_blocks:.0f} | Turns: {motion_turns:.0f}")
        
        now = time.time()
        
        # Check debounce delay
        if now - self.last_switch_time < DEBOUNCE_DELAY:
            time.sleep(CHECK_INTERVAL)
            continue
        
        # Determine which camera should be active
        blocks_active = motion_blocks > MOTION_SENSITIVITY
        turns_active = motion_turns > MOTION_SENSITIVITY
        
        # Switch logic: prioritize the camera with motion
        if turns_active and not blocks_active:
            if self.current_scene != SCENE_TURNS:
                if self.obs.switch_scene(SCENE_TURNS):
                    self.current_scene = SCENE_TURNS
                    self.last_switch_time = now
                    
        elif blocks_active and not turns_active:
            if self.current_scene != SCENE_BLOCKS:
                if self.obs.switch_scene(SCENE_BLOCKS):
                    self.current_scene = SCENE_BLOCKS
                    self.last_switch_time = now
        
        time.sleep(CHECK_INTERVAL)
```

# ==============================

# MAIN LOGIC

# ==============================

def main():
global race_running

```
logger.info("=== OBS Auto Camera Switcher ===")

# Initialize OBS controller
obs = OBSController(OBS_HOST, OBS_PORT, OBS_PASSWORD)
if not obs.connect():
    logger.error("Failed to connect to OBS. Exiting.")
    return

# Initialize cameras
cam_blocks = CameraManager(CAMERA_BLOCKS, "Blocks")
cam_turns = CameraManager(CAMERA_TURNS, "Turns")

if not cam_blocks.initialize() or not cam_turns.initialize():
    logger.error("Failed to initialize cameras. Exiting.")
    obs.disconnect()
    return

# Initialize auto-switcher
switcher = AutoCameraSwitcher(obs, cam_blocks, cam_turns)
switcher.start()

logger.info("System ready. Type 'start', 'stop', or 'exit'")

try:
    while True:
        cmd = input("> ").strip().lower()
        
        if cmd == "start":
            race_running = True
            obs.switch_scene(SCENE_BLOCKS)
            switcher.current_scene = SCENE_BLOCKS
            logger.info("Race STARTED - Auto-switching enabled")
            
        elif cmd == "stop":
            race_running = False
            obs.switch_scene(SCENE_BLOCKS)
            switcher.current_scene = SCENE_BLOCKS
            logger.info("Race STOPPED - Locked to Blocks scene")
            
        elif cmd == "status":
            current = obs.get_current_scene()
            logger.info(f"Current scene: {current}")
            logger.info(f"Race running: {race_running}")
            
        elif cmd == "exit":
            logger.info("Shutting down...")
            break
            
        else:
            logger.warning("Unknown command. Use: start, stop, status, exit")
            
except KeyboardInterrupt:
    logger.info("Interrupted by user")
finally:
    # Cleanup
    switcher.stop()
    cam_blocks.release()
    cam_turns.release()
    obs.disconnect()
    cv2.destroyAllWindows()
    logger.info("Shutdown complete")
```

if **name** == “**main**”:
main()
